内存队列节点
==

内存队列提供了一种异步消息缓存机制，此节点内部有个队列和一个处理线程。只要队列有内容，线程就可以从队列中获取消息，并进行处理。如果队列为空，则线程停止运行等待。

此节点是非可靠消息缓存机制，只是在消息流程处理中，针对大多数某些环节可能运行速度慢导致整个消息的流程出现大的时间误差而使用。比如：某个消息来源产生的数据频率很高，但数据很小，通过消息流处理，最终要写入文件或数据库中。如果每次消息都要触发文件或数据库写入，那么同步情况下，可能会反过来影响数据的采集，对于时间比较要求准确的场合这是不允许的。此时，就可以使用此节点，放置在数据库写入节点的前面。这样就可以保证流程前面节点处理速度。

另外，为了保证运行正常，此节点根据不同场合的需要，还提供了更多的支持，有如下：

1) 报警长度和最大长度：通过设置这两个参数，可以避免内存被滥用。当队列长度超过报警长度，就会产生报警，当队列达到最大长度，就不允许后续的消息进入，会直接抛错误。所以，要充分利用和调整好这两个参数。

2) 消息组合输出支持：如果设置了此功能，后续节点就可以批量处理队列中的数据，这个对于数据库写入来说是非常友好的。对于关系数据库来说，一次写入多条记录的效率比每次单独写入一条记录效率高很多。

3) 最新信息优先机制：如果被处理的消息时间准确度要求很高，且允许丢弃。那么可以使用此机制，这样既可以保证内存安全，同时还可以保证最新消息被处理。对于队列中的旧消息也支持多种丢弃策略。

<font color="red">

如果你发送的消息经过处理最后必须送达，如交易数据，则不能单独依赖此节点帮你解决问题。你应该考虑的是在处理之后发送前，消息必须被保存，只有本地保存成功之后，前端才能认为交易数据已经被接受。然后，通过后天消息流进行推送处理，并且有一定的反馈机制确定消息送达，然后才能在本地记录中进行标记或重新发送。


有了以上的思路，你就可以使用外部数据库和消息流来整体设计实现，当然里面你还可以使用本文的队列节点做一些性能优化。

你你要保证的关键点是：不管系统如何运行（含意外灾难），数据都不能丢失也不能失去一致性。
</font>

